# Concurrent Squares in Go

–ü—Ä–æ—Å—Ç–æ–π –ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è **–≥–æ—Ä—É—Ç–∏–Ω—ã**, **–∫–∞–Ω–∞–ª–æ–≤** –∏ **WaitGroup** –¥–ª—è –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ–≥–æ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∫–≤–∞–¥—Ä–∞—Ç–æ–≤ —á–∏—Å–µ–ª –≤ Go.

## üìå –û–ø–∏—Å–∞–Ω–∏–µ

- –°—Ä–µ–∑ `nums` —Å–æ–¥–µ—Ä–∂–∏—Ç —Å–ø–∏—Å–æ–∫ —á–∏—Å–µ–ª.
- –î–ª—è –∫–∞–∂–¥–æ–≥–æ —á–∏—Å–ª–∞ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–∞—è –≥–æ—Ä—É—Ç–∏–Ω–∞, –∫–æ—Ç–æ—Ä–∞—è —Å—á–∏—Ç–∞–µ—Ç –∫–≤–∞–¥—Ä–∞—Ç.
- –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ **–±—É—Ñ–µ—Ä–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª** `resultsCh`.
- `sync.WaitGroup` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ–∂–∏–¥–∞–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –≥–æ—Ä—É—Ç–∏–Ω.
- –ü–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è –≤—Å–µ—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –æ–Ω–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ —Å—Ä–µ–∑ `out` –ø–æ –∏—Å—Ö–æ–¥–Ω—ã–º –∏–Ω–¥–µ–∫—Å–∞–º.
- –ò—Ç–æ–≥–æ–≤—ã–π –≤—ã–≤–æ–¥ –≤—Å–µ–≥–¥–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç –ø–æ—Ä—è–¥–∫—É —á–∏—Å–µ–ª –≤ `nums`.

## üß© –ö–æ–¥

```go
package main

import (
	"fmt"
	"sync"
)

type result struct {
	idx int
	n   int
	sq  int
}

func main() {
	nums := []int{2, 4, 6, 8, 10}
	resultsCh := make(chan result, len(nums))
	var wg sync.WaitGroup
	for i, n := range nums {
		wg.Add(1)
		go func(i, x int) {
			defer wg.Done()
			sq := x * x
			resultsCh <- result{
				idx: i,
				n:   x,
				sq:  sq,
			}
		}(i, n)
	}
	wg.Wait()
	out := make([]result, len(nums))
	for i := 0; i < len(nums); i++ {
		r := <-resultsCh
		out[r.idx] = r
	}
	for _, r := range out {
		fmt.Printf("%d^2 = %d\n", r.n, r.sq)
	}
}
